})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
tail(resThree[[1]]$fullPost)
tail(resThree[[2]]$fullPost)
tail(resThree[[3]]$fullPost)
options(digits = '22')
resThree[[1]]$initsList$beta
round(resThree[[1]]$initsList$beta*1e6, 6)/1e6
round(resThree[[1]]$initsList$beta*1e6, 7)/1e6
signif(round(resThree[[1]]$initsList$beta*1e6, 7)/1e6)
round(resThree[[1]]$initsList$beta*1e16, 7)/1e16
exp(round(resThree[[1]]$initsList$beta*1e16, 7)/1e16)
devtools::install_github("ceward18/BayesSEIR")
i <- 1
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
# create data frame of all possible models to be fit
maxInfs <- c(15, 20)
nSim <- 100
modelsGamma <- expand.grid(iddFun = 'dgammaIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLognormal <- expand.grid(iddFun = 'dlnormIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLogit <- expand.grid(iddFun = 'logitIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = 'IDD_logit',
stringsAsFactors = FALSE)
modelsSpline <- expand.grid(iddFun = 'splineIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp', 'IDD_logit'),
stringsAsFactors = FALSE)
# 1600 models to be fit
allModels <- rbind.data.frame(modelsGamma,
modelsLognormal,
modelsLogit,
modelsSpline)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
iddFun_i <- allModels$iddFun[i]
simNumber_i <- allModels$simNumber[i]
maxInf_i <- allModels$maxInf[i]
datGen_i <- allModels$datGen[i]
print(paste0('IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 500000
nburn <- 100000
# set seed for reproducibility of initial values
set.seed(x + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
set.seed(x)
fullPost <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE, seed = x)
list(fullPost = fullPost,
initsList = initsList)
})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
tail(resThree[[1]]$fullPost)
tail(resThree[[2]]$fullPost)
tail(resThree[[3]]$fullPost)
resThree[[1]]$initsList
resThree[[2]]$initsList
resThree[[3]]$initsList
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
if (file.exists(paste0('./batch_output/estimatedE_batch', idx, '.rds'))) {
stop('this already ran!')
}
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
datGens <- c('PS', 'IDD_peak', 'IDD_exp', 'IDD_logit')
maxInfs <- c(15, 20)
nSim <- 100
modelsIDD <- expand.grid(datGen = datGens,
infPeriodSpec = 'IDD',
iddFun = c('dgammaIDD', 'dlnormIDD', 'logitIDD', 'splineIDD'),
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsIDD <- modelsIDD[order(modelsIDD$datGen, modelsIDD$infPeriodSpec,
modelsIDD$iddFun, modelsIDD$maxInf, modelsIDD$simNumber),]
modelsExp <- expand.grid(datGen = datGens,
infPeriodSpec = 'exp',
iddFun = NA,
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsExp <- modelsExp[order(modelsExp$datGen, modelsExp$infPeriodSpec,
modelsExp$iddFun, modelsExp$maxInf, modelsExp$simNumber),]
modelsPS <- expand.grid(datGen = datGens,
infPeriodSpec = 'PS',
iddFun = NA,
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsPS <- modelsPS[order(modelsPS$datGen, modelsPS$infPeriodSpec,
modelsPS$iddFun, modelsPS$maxInf, modelsPS$simNumber),]
# 4800 models to run (6 models * 4 data generation * 2 maxInfs * 100 sims)
# IDD 1 - 3200
# Exp 3201 - 4000
# PS 4001 - 4800
allModels <- rbind.data.frame(modelsIDD, modelsExp, modelsPS)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
idx <- 4003
infPeriodSpec_i <- allModels$infPeriodSpec[idx]
iddFun_i <- allModels$iddFun[idx]
simNumber_i <- allModels$simNumber[idx]
maxInf_i <- allModels$maxInf[idx]
datGen_i <- allModels$datGen[idx]
print(paste0('Model: ', infPeriodSpec_i,
', IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Istar
# trim/add to Istar and Estar in the case of excess 0's
# need maxInf days after last infection start
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
X
datList
Istar
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
idx <- 1
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
# create data frame of all possible models to be fit
maxInfs <- c(15, 20)
nSim <- 100
modelsGamma <- expand.grid(iddFun = 'dgammaIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLognormal <- expand.grid(iddFun = 'dlnormIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLogit <- expand.grid(iddFun = 'logitIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = 'IDD_logit',
stringsAsFactors = FALSE)
modelsSpline <- expand.grid(iddFun = 'splineIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp', 'IDD_logit'),
stringsAsFactors = FALSE)
# 1600 models to be fit
allModels <- rbind.data.frame(modelsGamma,
modelsLognormal,
modelsLogit,
modelsSpline)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
# fit models in batches of 100 (16 batches total)
# each batch is one model/data generation scenario
batchSize <- 100
batchIdx <- batchSize * (idx - 1) + 1:batchSize
for (i in batchIdx) {
iddFun_i <- allModels$iddFun[i]
simNumber_i <- allModels$simNumber[i]
maxInf_i <- allModels$maxInf[i]
datGen_i <- allModels$datGen[i]
print(paste0('IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i + 1 <= fullTime) {
newTime <- lastInfTime + maxInf_i + 1
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i + 1 - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 1e6
nburn <- 2e5
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
### post processing to get Gelman-Rubin and IDD curve estimates
postSummaries <- post_processing(modelOutput = resThree, EType = 'known',
infPeriodSpec = "IDD",
datGen = datGen_i, iddFun = iddFun_i,
simNumber = simNumber_i, maxInf = maxInf_i,
X = X, N = N)
iddSummary <- postSummaries$iddSummary
iddSummary$allConverge <- all(postSummaries$gdiag$gr < 1.1)
# concatenate results across batches for output
if (i == batchIdx[1]) {
batchOutput <- iddSummary
} else {
batchOutput <- rbind.data.frame(batchOutput, iddSummary)
}
} # end loop
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
idx <- 1
if (file.exists(paste0('./batch_output/estimatedE_batch', idx, '.rds'))) {
stop('this already ran!')
}
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
datGens <- c('PS', 'IDD_peak', 'IDD_exp', 'IDD_logit')
maxInfs <- c(15, 20)
nSim <- 100
modelsIDD <- expand.grid(datGen = datGens,
infPeriodSpec = 'IDD',
iddFun = c('dgammaIDD', 'dlnormIDD', 'logitIDD', 'splineIDD'),
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsIDD <- modelsIDD[order(modelsIDD$datGen, modelsIDD$infPeriodSpec,
modelsIDD$iddFun, modelsIDD$maxInf, modelsIDD$simNumber),]
modelsExp <- expand.grid(datGen = datGens,
infPeriodSpec = 'exp',
iddFun = NA,
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsExp <- modelsExp[order(modelsExp$datGen, modelsExp$infPeriodSpec,
modelsExp$iddFun, modelsExp$maxInf, modelsExp$simNumber),]
modelsPS <- expand.grid(datGen = datGens,
infPeriodSpec = 'PS',
iddFun = NA,
maxInf = maxInfs,
simNumber = 1:nSim,
stringsAsFactors = FALSE)
modelsPS <- modelsPS[order(modelsPS$datGen, modelsPS$infPeriodSpec,
modelsPS$iddFun, modelsPS$maxInf, modelsPS$simNumber),]
# 4800 models to run (6 models * 4 data generation * 2 maxInfs * 100 sims)
# IDD 1 - 3200
# Exp 3201 - 4000
# PS 4001 - 4800
allModels <- rbind.data.frame(modelsIDD, modelsExp, modelsPS)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
infPeriodSpec_i <- allModels$infPeriodSpec[idx]
iddFun_i <- allModels$iddFun[idx]
simNumber_i <- allModels$simNumber[idx]
maxInf_i <- allModels$maxInf[idx]
datGen_i <- allModels$datGen[idx]
print(paste0('Model: ', infPeriodSpec_i,
', IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
# need maxInf days after last infection start
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i + 1 <= fullTime) {
newTime <- lastInfTime + maxInf_i  + 1
Istar <- Istar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i  + 1 - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### set up priors and initial values
# run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'infPeriodSpec_i', 'iddFun_i',
'datGen_i', 'maxInf_i', 'idx'))
resThree <- parLapplyLB(cl, 1:3, function(x) {
library(BayesSEIR)
library(splines)
# MCMC specifications
# total number of iterations to be run
if (infPeriodSpec_i == 'exp') {
niter <- 1e6
} else if (infPeriodSpec_i == 'PS') {
niter <- 5e5
} else if (infPeriodSpec_i == 'IDD') {
niter <- 1.3e6
}
# number of burn-in iterations to be discarded
nburn <- 2e5
# set seed for reproducibility of initial values
set.seed(x + idx)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = infPeriodSpec_i,
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
# set seed for reproducibility of chains
set.seed(x)
# start timing for MCMC efficiency
startTime <- Sys.time()
if (infPeriodSpec_i == 'exp') {
res <-  mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = infPeriodSpec_i,
priors = priorList,
WAIC = TRUE)
} else if (infPeriodSpec_i == 'PS') {
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = infPeriodSpec_i,
priors = priorList,
dist = 'gamma', maxInf = maxInf_i,
WAIC = TRUE)
} else if (infPeriodSpec_i == 'IDD') {
res <-  mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = infPeriodSpec_i,
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
WAIC = TRUE)
}
endTime <- Sys.time()
res$chainTime <- as.numeric(endTime - startTime, units = 'mins')
res
})
stopCluster(cl)
