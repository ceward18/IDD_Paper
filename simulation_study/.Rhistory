# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 1e5
nburn <- 50000
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
i <- 1
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
# create data frame of all possible models to be fit
maxInfs <- c(15, 20)
nSim <- 100
modelsGamma <- expand.grid(iddFun = 'dgammaIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLognormal <- expand.grid(iddFun = 'dlnormIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLogit <- expand.grid(iddFun = 'logitIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = 'IDD_logit',
stringsAsFactors = FALSE)
modelsSpline <- expand.grid(iddFun = 'splineIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp', 'IDD_logit'),
stringsAsFactors = FALSE)
# 1600 models to be fit
allModels <- rbind.data.frame(modelsGamma,
modelsLognormal,
modelsLogit,
modelsSpline)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
iddFun_i <- allModels$iddFun[i]
simNumber_i <- allModels$simNumber[i]
maxInf_i <- allModels$maxInf[i]
datGen_i <- allModels$datGen[i]
print(paste0('IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 50000
nburn <- 10000
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
sessionInfo()
si <- sessionInfo()
si$BLAS
getwd()
system('echo $PATH')
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
j <- 1
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
# create data frame of all possible models to be fit
maxInfs <- c(15, 20)
nSim <- 100
modelsGamma <- expand.grid(iddFun = 'dgammaIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLognormal <- expand.grid(iddFun = 'dlnormIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLogit <- expand.grid(iddFun = 'logitIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = 'IDD_logit',
stringsAsFactors = FALSE)
modelsSpline <- expand.grid(iddFun = 'splineIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp', 'IDD_logit'),
stringsAsFactors = FALSE)
# 1600 models to be fit
allModels <- rbind.data.frame(modelsGamma,
modelsLognormal,
modelsLogit,
modelsSpline)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
i <- 1
iddFun_i <- allModels$iddFun[i]
simNumber_i <- allModels$simNumber[i]
maxInf_i <- allModels$maxInf[i]
datGen_i <- allModels$datGen[i]
print(paste0('IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 50000
nburn <- 10
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
tail(resThree[[1]]$fullPost)
tail(resThree[[2]]$fullPost)
tail(resThree[[3]]$fullPost)
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 70000
nburn <- 10
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
tail(resThree[[1]]$fullPost)
tail(resThree[[2]]$fullPost)
tail(resThree[[3]]$fullPost)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 1000000
nburn <- 10
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
head(resThree[[1]]$fullPost)
head(resThree[[2]]$fullPost)
head(resThree[[3]]$fullPost)
tail(resThree[[1]]$fullPost)
tail(resThree[[2]]$fullPost)
tail(resThree[[3]]$fullPost)
dim(resThree[[1]]$fullPost)
devtools::install_github("ceward18/BayesSEIR")
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
devtools::install_github("ceward18/BayesSEIR")
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
i <- 1
### load libraries
library(parallel)
library(coda)
library(splines)
library(BayesSEIR)
source('../helper_functions.R')
source('post_processing.R')
# create data frame of all possible models to be fit
maxInfs <- c(15, 20)
nSim <- 100
modelsGamma <- expand.grid(iddFun = 'dgammaIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLognormal <- expand.grid(iddFun = 'dlnormIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp'),
stringsAsFactors = FALSE)
modelsLogit <- expand.grid(iddFun = 'logitIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = 'IDD_logit',
stringsAsFactors = FALSE)
modelsSpline <- expand.grid(iddFun = 'splineIDD',
simNumber = 1:nSim,
maxInf = maxInfs,
datGen = c('IDD_peak', 'IDD_exp', 'IDD_logit'),
stringsAsFactors = FALSE)
# 1600 models to be fit
allModels <- rbind.data.frame(modelsGamma,
modelsLognormal,
modelsLogit,
modelsSpline)
# model specifications that are the same for all models
N <- 5363500
E0 <- 1
I0 <- 0
S0 <- N - E0 - I0
# intervention time
tstar <- 120
iddFun_i <- allModels$iddFun[i]
simNumber_i <- allModels$simNumber[i]
maxInf_i <- allModels$maxInf[i]
datGen_i <- allModels$datGen[i]
print(paste0('IDD Fun: ', iddFun_i,
', data gen: ', datGen_i,
', max inf: ', maxInf_i,
', sim number: ', simNumber_i))
############################################################################
### set up data
# load data
dat <- readRDS(paste0('data/', datGen_i, '_data.rds'))
# extract data for simulation of interest
Istar <- dat$Istar[,simNumber_i]
Estar <- dat$Estar[,simNumber_i]
# trim/add to Istar and Estar in the case of excess 0's
fullTime <- length(Istar)
lastInfTime <- max(which(Istar > 0))
if (lastInfTime + maxInf_i <= fullTime) {
newTime <- lastInfTime + maxInf_i
Istar <- Istar[1:newTime]
Estar <- Estar[1:newTime]
} else {
zerosAdd <- lastInfTime + maxInf_i - fullTime
Istar <- c(Istar, rep(0, zerosAdd))
Estar <- c(Estar, rep(0, zerosAdd))
newTime <- length(Istar)
}
# design matrix for intervention
X <- getX(newTime, tstar)
datList <- list(Istar = Istar,
Estar = Estar,
S0 = S0,
E0 = E0,
I0 = I0,
N = N)
############################################################################
### run three chains in parallel
cl <- makeCluster(3)
clusterExport(cl, list('datList',  'X', 'iddFun_i', 'datGen_i',
'maxInf_i', 'i'))
resThree <- parLapplyLB(cl, X = 1:3, fun = function(clIdx) {
library(BayesSEIR)
library(splines)
# MCMC specifications
niter <- 600000
nburn <- 500000
# set seed for reproducibility of initial values
set.seed(clIdx + i)
# get priors and initial values based on model/data generating scenario
source('get_priors_inits.R')
priorsInits <- get_priors_inits(infPeriodSpec = 'IDD',
iddFun = iddFun_i,
datGen = datGen_i,
maxInf = maxInf_i)
initsList<- priorsInits$initsList
priorList<- priorsInits$priorList
res <- mcmcSEIR(dat = datList, X = X,
inits = initsList,
niter = niter, nburn = nburn,
infPeriodSpec = 'IDD',
priors = priorList,
iddFun = iddFun_i, maxInf = maxInf_i,
EKnown = TRUE,
WAIC = TRUE)
list(fullPost = res$fullPost,
waic = res$WAIC,
seed = clIdx + i,
initsList = initsList,
chain = clIdx)
})
stopCluster(cl)
?ramcmc::adapt_S
setwd("C:/Users/caitl/Documents/IDDPaper/IDD_Paper/simulation_study")
